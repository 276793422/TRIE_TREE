	Author: Zoo
	QQ:276793422

		模块说明
	当前模块是一个支持跨平台的全动态申请的前缀树，
	由于前一阵子需要用到一个前缀树，
	本来想在网上找一个，但是我就没有找到全动态申请内存的前缀树，
	网上的各种前缀树都是子列表元素个数确定的，
	但是我用前缀树的目的是用来存放文件路径，
	文件路径的字符串是包含中文字符的，
	这样，如果把子列表元素个数确定的话，
	那么就可能需要每个树节点都需要0xFFFF个指针元素，
	如果真的是这样，就疯了，内存浪费过多，x86环境，一个节点就要用掉256K内存，x64下翻倍，
	所以我的需求是找到一个全动态内存申请的前缀树，
	可是，我找了各大平台，各大开源代码，都没有找到，
	也可能是我个人水平不足，寻找的不够多，
	所以我自己写了一个全动态内存申请的前缀树，
	使用起来相对比较麻烦，但是抽象出了几乎全部需要平台支持的部分，
	使用时，需要在各自平台上支持一系列的内存申请释放相关函数，
	然后就可以随意用了，
	所有接口全部封装在内部，外部不需要知道任何结构体信息。

		当前模块缺陷（已修复，可以支持从右侧开始找规则）
	模糊查找时，可以从根节点开始寻找信息，
	这样本身是没问题的，但是实际上不是很合逻辑，
	因为道理上来说需要如果对一个文件做操作，它所在的目录才应该影响它的行为，而不是根目录。
	比如，列表中有四条规则 
		D:\\1\\2\\3\\4.c
		D:\\1\\2\\3\\
		D:\\1\\2\\
		D:\\1\\
	这时如果我要查询 D:\\1\\2\\3\\4.c 这个路径的规则
		那么，精确查找的话，会直接找到 D:\\1\\2\\3\\4.c 这条路径的规则，
	但是如果我要查询 D:\\1\\2\\3\\5.c 这个路径的规则
		由于实际上对应路径的规则不存在，那么精确查找就会失败
		但是如果用现有的模糊查找，只能先找到 D:\\1\\ 目录的规则
			但是实际上 D:\\1\\2\\3\\ 这个目录的规则才是应该找到的

	目前问题是测试用例不足，写了大部分用例，但是有些仍然不够